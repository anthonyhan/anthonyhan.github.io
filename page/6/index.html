<!doctype html><html><head><meta name=generator content="Hugo 0.113.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>LimboNova | Home</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Powered by Hugo."><meta property="og:image" content><link rel=alternate type=application/rss+xml href=/index.xml title=LimboNova><meta property="og:title" content="LimboNova"><meta property="og:description" content="Powered by Hugo."><meta property="og:type" content="website"><meta property="og:url" content="/"><meta name=twitter:card content="summary"><meta name=twitter:title content="LimboNova"><meta name=twitter:description content="Powered by Hugo."><script src=/js/feather.min.js></script>
<link href=/css/fonts.11a1877508139eac0b5b4852ceb110c35641b3533321e66e39149e901ed5756b.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=/css/main.d902908ac6e0fab67957de5db5aea1b6455b19ae2ca98eac4c95a4a0fdc02238.css><link id=darkModeStyle rel=stylesheet type=text/css href=/css/dark.c95c5dcf5f32f8b67bd36f7dab66680e068fce2b303087294114aabf7a7c080b.css media="(prefers-color-scheme: dark)"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script>
<script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body><div class=content><header><div class=main><a href=/>LimboNova</a></div><nav><a href=/>Home</a>
<a href=/posts>Archives</a>
<a href=/tags>Tags</a>
<a href=/about>About</a></nav></header><main class=list><div class=site-description><p>Seize the Day</p></div><section class=list-item><h1 class=title><a href=/posts/gif-format-and-lzw/>GIF 格式及LZW算法浅析</a></h1><time>Sep 20, 2012</time><br><div class=description><p>前段时间得知一个产品需求，需要在Flash Player中显示gif动画图片。虽然Flash支持gif图像的载入，但无法播放动画。</p><p>花了不少时间去了解GIF格式，虽然顺利解决了问题，但是知其然也知其所以然，了解了这些知识，对理解编码/解码的过程和解决问题有非常大的帮助。</p><p><img src=/images/diego.gif alt="gif sample" title="GIF 多帧动画"></p><h2 id=gif概述>GIF概述</h2><p>Graphics Interchange Format（GIF，图形交换格式）是一种位图的图形文件格式，以8位色（即256种颜色）重现真彩色的图像。它实际上是一种压缩文档，采用LZW压缩算法进行编码，有效地减少了图像文件在网络上传输的时间。是目前广泛应用于网络传输的图像格式之一。</p><p>GIF主要分为两个版本，即GIF 87a和GIF 89a：</p><p>GIF 87a：是在1987年制定的版本；
GIF 89a：是在1989年制定的版本。在这个版本中，为GIF文档扩充了图形控制区块、备注、说明、应用程序接口等四个区块，并提供了对透明色和多帧动画的支持。</p><h2 id=gif格式结构>GIF格式结构</h2><p>GIF文件由文件头，描述块，彩色表，数据块，扩展块和结束符构成，GIF87a和GIF89a的区别在于：后者较前者增加了扩展块，从功能上看即提供了对透明色和多帧动画的支持。</p><h3 id=结构组成>结构组成</h3><p>结构如下表所示：</p><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>Header</td><td>Header</td><td>Header</td></tr><tr><td>Logical Screen Descriptor</td><td>Screen Descriptor Block</td><td>GIF Data Stream</td></tr><tr><td>Global Color Table</td><td>Global Color Table(optional)</td><td></td></tr><tr><td>Application Extension</td><td>Extension Blocks(optional, repeated)</td><td></td></tr><tr><td>Graphic Control Extension*</td><td></td><td></td></tr><tr><td>…</td><td></td><td></td></tr><tr><td>Image Descriptor</td><td>Image Blocks(repeated)</td><td></td></tr><tr><td>Local Color Table</td><td></td><td></td></tr><tr><td>Table Based Image Data</td><td></td><td></td></tr><tr><td>…</td><td>Extension Blocks(optional, repeated)</td><td></td></tr><tr><td>Trailer</td><td>Trailer</td><td>Trailer</td></tr></tbody></table>&mldr;</div><a class=readmore href=/posts/gif-format-and-lzw/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/asc2-release-notes/>Adobe® ActionScript® Compiler 2.0 (ASC2.0)版本说明</a></h1><time>Aug 31, 2012</time><br><div class=description><p>伴随着Flash Builder 4.7 beta的发布，正如Adobe所承诺的那样，新的编译器也浮出水面。全新的编译器到底有哪些改进和新特性，想必是大多数ActionScript开发比较关心的问题。简单翻译了下ASC2.0官方发布说明，希望能对同行们有一点帮助。</p><p>如果要了解Flash Builder 4.7，可以参看zrong的<a href=http://zengrong.net/post/1676.htm>这篇文章</a>。</p><p>** August 2012 – Adobe® ActionScript® Compiler 2.0 (Build 2.0.0.345083) **
Welcome to the Adobe ActionScript Compiler 2.0 (ASC 2.0) Preview.</p><p>ASC 2.0 是一个新的ActionScript® 3.0 (AS3)编译器。相比之前版本更遵循AS3语言规范，编译性能方面有了很大改善。在内存压力下更稳定，并包含一些演示性的优化选项（内联，无用代码删除），这些选项可以有选择地启用。</p><p>这个编译器已经包含在刚发布的 Flash Builder® 4.7 预览版中。其单独版本已经同AIR SDK 3.4 一起打包发布。</p><p>注意：ASC 2.0支持编译AS3应用，虽然留有熟悉的mxmlc和compc命令行入口，但是不支持Flex应用的编译。</p><p>当有更多信息时，该文档可能会不定期更新。</p><h2 id=版本说明--august-2012>版本说明 – August 2012</h2><ul><li>这是新编译器ASC 2.0 的第一个公开预览版；</li><li>Flash Builder 4.7 and the ASC 2.0 command-line compiler now share the same code model. This avoids duplicate representations of a program and means the IDE has an accurate representation of the language – matching the compiler. （没看懂，不清楚code model，representation的定义）</li><li>全新多线程架构，支持多文件同时编译，减少编译时间；</li><li>更佳的常数合并和常数传播带来运行时更佳性能的代码；</li><li>通过移除不必要的活动记录减少函数开销；</li><li>包含内联和无用代码删除相关的字节码优化；</li><li>加入新关键字”goto”，实现AS3的非线性控制流；</li><li>现在支持SWF 13的LZMA压缩了。</li><li>新的符号管理系统，意味着包含Flash 和 AIR项目的Flash Builder 4.7 AS工作空间，编译起来应该会快多了；</li><li>fontswf, optimizer，swfdump和swcdepends ，基于ASC 2.0的新版本可以用了；</li><li>Asdoc，fdb的旧版本依然包括在内；</li><li>字体转码已经从[Embed]语法中移除，现在字体需要先预转码并作为SWF嵌入，可以通过工具（如fontswf或Flash Professional CS6）来完成。</li><li>源代码中的相对路径（[Embed] assets, includes, etc…）将从其包含文件相对解析。要指定一个相对于源文件根目录的路径，需要在你的路径前加”/”；</li><li>英文编译器错误信息已经翻译成法文，日文，中文，区域取决于JVM的设置，并可以通过 -tools-locale 设置项改写。</li></ul>&mldr;</div><a class=readmore href=/posts/asc2-release-notes/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/connecting-your-kindle-fire-to-adb/>连接Kindle Fire到ADB(实体机调试)</a></h1><time>Aug 19, 2012</time><br><div class=description><h2 id=前提条件>前提条件</h2><p>为开发环境下载安装下列包:</p><ul><li><a href=http://www.oracle.com/technetwork/java/javase/downloads/index.html>Java JDK</a></li><li><a href=http://developer.android.com/sdk/index.html>Android SDK</a></li></ul><p>使用 Android SDK Manager 下载安装下列SDK包：</p><ul><li>Android 2.3.3 (API10) => SDK Platform</li><li>Tools => Android SDK Tools</li><li>Tools => Android SDK Platform-tools</li><li>Extras => Google USB Driver package</li></ul><h2 id=osx设置>OSX设置</h2><p>修改 adb_usb.ini</p><ol><li>打开文件： ~/.android/adb_usb.ini</li><li>添加一行： 0x1949</li><li>添加一行： 0x0006</li><li>保存文件</li></ol><p>注意：确保每行一条配置。如果文件不存在，新建文件并确认具备已配置完毕的Android SDK。</p>&mldr;</div><a class=readmore href=/posts/connecting-your-kindle-fire-to-adb/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/similar-image-searching-algorithm-as3/>基于AS3.0的相似图像搜索算法实现</a></h1><time>Aug 14, 2012</time><br><div class=description><p>Google的图像搜索，可以根据用户上传或者网络上的图片找到与此最相似的图片(百度也有类似功能)。</p><p><img src=https://pjkm4w.bay.livefilestore.com/y1pOjCa3mvtvwKjegr_UmRLkNG9nUpMQU-uMfHod4eqmrtsEsIHz4jI_4yyhi7oe7xURPx9ZOu-lMQsUi8FbN4reRvqjqVlik3i/google_image_search.png alt="google image search" title="Google Image Search"></p><p>阮一峰的博客曾经提到过 “感知哈希算法(Perceptual hash algorithm)”，主要介绍了 Dr. Neal Krawetz基于感知哈希算法的”平均哈希算法(Average Hash algorithm)”。相比其他算法，这种算法简单快速，很容易实现。</p><p>对于图像来说，高频信息体现图像的细节，低频信息体现图像的边缘和轮廓。一幅大而清晰的图像不仅包含低频，而且会包含很多高频分量。而小图片因为缺乏细节部分，往往只有低频信息。因此用只包含低频分量的图像来做图像相似度匹配是非常合适的。</p><p>感知哈希算法的基本原理是根据图像特征生成一个特定(但非唯一)的指纹，根据指纹来比较图像的相似度。其特点是，即使图像放大缩小，调整高宽，或者有少许色彩变化（对比度，亮度等等），仍然可以匹配到相似的图像。</p><h2 id=平均哈希算法average-hash-algorithm>平均哈希算法(Average Hash algorithm)</h2><p>实现步骤如下：</p><ol><li><p>缩小尺寸：移除高频部分，将图像缩小至8×8像素,不考虑高宽比；
{% img <a href=https://pjkm4w.bay.livefilestore.com/y1pEQIINXhwtkYhvSu94Q9L0iRya9-bx-0UDrNZDL8yb3_2ODB88DXQAhb3f4Oe8J9Kj8eElRgB1nZy95uSdf8Uye0dNGwDPpWW/reduce_size.jpg>https://pjkm4w.bay.livefilestore.com/y1pEQIINXhwtkYhvSu94Q9L0iRya9-bx-0UDrNZDL8yb3_2ODB88DXQAhb3f4Oe8J9Kj8eElRgB1nZy95uSdf8Uye0dNGwDPpWW/reduce_size.jpg</a> 64 64 %}</p></li><li><p>减少颜色：转为灰度图，将64像素的RGB 64×3个颜色值简化为 64个色值；
{% img <a href=https://pjkm4w.bay.livefilestore.com/y1pEQIINXhwtkZyypWiFbXh51KEaUsH1RT_1Qli_UpOupdO-_1PbPXCbINY0UQRbfgfHPmXyoTqz0kcq963cYITTxHLInBtZQGl/reduce_color.jpg>https://pjkm4w.bay.livefilestore.com/y1pEQIINXhwtkZyypWiFbXh51KEaUsH1RT_1Qli_UpOupdO-_1PbPXCbINY0UQRbfgfHPmXyoTqz0kcq963cYITTxHLInBtZQGl/reduce_color.jpg</a> 64 64 %}</p></li><li><p>计算平均值：计算64个颜色的均值；</p></li><li><p>比较灰度值：将每个像素的颜色值与平均值比较，小于均值记0，否则记1；</p></li><li><p>计算哈希值：将上述的比较结果拼起来构成一个64位的整数。</p></li></ol>&mldr;</div><a class=readmore href=/posts/similar-image-searching-algorithm-as3/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/actionscript-3-0-closure/>ActionScript 3.0 闭包及作用域</a></h1><time>Aug 5, 2012</time><br><div class=description><p>闭包作为动态语言的基石，在OO实现和框架构建上有着-十分重要的作用。但是闭包的定义比较抽象，不利于理解，闭包在各语言中的实现不尽相同，闭包的函数作用域也有区别。</p><p>参考整理了这篇文章(非原创),主要内容来自</p><ul><li>IBM Thoughtworks 文档：<a href=http://www.ibm.com/developerworks/cn/linux/l-cn-closure>闭包的概念、形式与应用</a>；</li><li>Adobe官方文档：<a href=http://www.ibm.com/developerworks/cn/linux/l-cn-closure/>Flash ActionScript 3.0 编程- 函数作用域</a>。</li></ul><h2 id=什么是闭包>什么是闭包</h2><p>闭包的概念出现于60年代，最早实现闭包的程序语言是<a href=http://zh.wikipedia.org/wiki/Scheme>Scheme</a>。关于闭包的定义，说法比较多。</p><ul><li><p><a href=http://zh.wikipedia.org/wiki/Scheme>Scheme</a>语言设计者这样定义闭包：”we introduce the notion of a closure which is a data structure containing a lambda expression, and an environment to be used when that lambda expression is applied to arguments.”</p></li><li><p>英文Wikipedia 则是解释为：”a closure (also lexical closure or function closure) is a <a href=http://en.wikipedia.org/wiki/Function_(computer_science)>function</a> together with a referencing environment for the <a href=http://en.wikipedia.org/wiki/Non-local_variable>non-local variables</a> of that function. “。</p></li><li><p>中文维基百科：”在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了<a href=http://zh.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F>自由变量</a>的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。”
综合这些定义，可以认为闭包一种特殊的数据结构，不仅仅是函数，还包括与其相关的引用环境。闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束所组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。那么为什么要把引用环境与函数组合起来呢？这主要是因为在支持嵌套作用域的语言中，有时不能简单直接地确定函数的引用环境。这样的语言一般具有这样的特性：</p></li><li><p>函数是一阶值（First-class value），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值。</p></li><li><p>函数可以嵌套定义，即在一个函数内部可以定义另一个函数。</p></li></ul><h2 id=闭包作用域>闭包作用域</h2><p>函数的范围不但决定了可以在程序中的什么位置调用函数，而且还决定了函数可以访问哪些定义。适用于变量标识符的作用域规则同样也适用于函数标识符。在全局作用域中声明的函数在整个代码中都可用。例如，ActionScript 3.0 包含可在代码中的任意位置使用的全局函数，如 isNaN() 和 parseInt()。嵌套函数（即在另一个函数中声明的函数）可以在声明它的函数中的任意位置上使用。</p><h3 id=作用域链the-scope-chain>作用域链(The scope chain)</h3><p>无论何时开始执行函数，都会创建许多对象和属性。首先，会创建一个称为激活对象 的特殊对象，该对象用于存储在函数体内声明的参数以及任何局部变量或函数。由于激活对象属于内部机制，因此您无法直接访问它。接着，会创建一个范围链，其中包含由 Flash Player 或 Adobe AIR 检查标识符声明的对象的有序列表。所执行的每个函数都有一个存储在内部属性中的作用域链。对于嵌套函数，范围链始于其自己的激活对象，后跟其父函数的激活对象。作用域链以这种方式延伸，直到到达全局对象。全局对象是在 ActionScript 程序开始时创建的，其中包含所有的全局变量和函数。</p>&mldr;</div><a class=readmore href=/posts/actionscript-3-0-closure/>Read more ⟶</a></section><section class=list-item><h1 class=title><a href=/posts/actionscript3-inheritance-mechanism/>ActionScript3的继承机制</a></h1><time>Jul 31, 2012</time><br><div class=description><p>因为从Flex 3时开始使用ActionScript，所以错过了ActionScript 3.0之前的时代。虽然知晓ActionScript是遵循<a href=http://zh.wikipedia.org/zh/ECMAScript>ECMAScript</a> 标准的动态语言。但是自AS3.0 之后变化很大，看AS2.0 和 AS3.0的代码，如同javaScript 和 java 的差别。后来了解到AS3.0有两种继承机制：原型继承(prototype)和固定属性继承(traits)，从中能明显看出这门语言的所历经的改变和革新：为什么会支持动态类型，为什么用原型继承，为什么又会有固定属性继承？为什么静态属性，静态方法无法被继承……这些由于历史原因而遗留的种种疑问也就迎刃而解。</p><p>本文主要内容源自Adobe官方教程：<a href=http://help.adobe.com/zh_CN/ActionScript/3.0_ProgrammingAS3/WS5b3ccc516d4fbf351e63e3d118a9b90204-7f3f.html>ActionScript 中面向对象的编程-高级主题</a> ，图文并茂，外加代码诠释，介绍得详细易懂，因此我也不想加多余的内容。</p><p>本节开始先简单介绍 ActionScript 和 OOP 的历史，然后讨论 ActionScript 3.0 对象模型，以及该模型如何启用新的 ActionScript 虚拟机 (AVM2) 显著提供运行速度（与包含旧 ActionScript 虚拟机 (AVM1) 的以前版本的 Flash Player 相比）。</p><h2 id=actionscript-oop-支持的历史>ActionScript OOP 支持的历史</h2><p>由于 ActionScript 3.0 是在以前版本的 ActionScript 基础上构建的，了解 ActionScript 对象模型的发展过程可能有所帮助。ActionScript 最初作为早期版本的 Flash 创作工具的简单编写脚本机制。后来，程序员开始使用 ActionScript 建立更加复杂的应用程序。为了迎合这些程序员的需要，每个后续版本都添加了一些语言功能以帮助创建复杂的应用程序。</p><h3 id=actionscript-10>ActionScript 1.0</h3><p>ActionScript 1.0 指在 Flash Player 6 和更早版本中使用的语言版本。即使在这个早期开发阶段，ActionScript 对象模型也是建立在基础数据类型对象的概念的基础上。ActionScript 对象是由一组属性 构成的复合数据类型。讨论对象模型时，术语属性 包括附加到对象的所有内容，如变量、函数或方法。</p><p>尽管第一代 ActionScript 不支持使用 class 关键字定义类，但是可以使用称为原型对象的特殊对象来定义类。Java 和 C++ 等基于类的语言中使用 class 关键字创建要实例化为具体对象的抽象类定义，而 ActionScript 1.0 等基于原型的语言则将现有对象用作其它对象的模型（或原型）。基于类的语言中的对象可能指向作为其模板的类，而基于原型的语言中的对象则指向作为其模板的另一个对象（即其原型）。</p><p>要在 ActionScript 1.0 中创建类，可以为该类定义一个构造函数。在 ActionScript 中，函数不只是抽象定义，还是实际对象。您创建的构造函数用作该类实例的原型对象。以下代码创建一个名为 Shape 的类，还定义一个名为 visible 的属性，该属性默认情况下设置为 true：</p>&mldr;</div><a class=readmore href=/posts/actionscript3-inheritance-mechanism/>Read more ⟶</a></section><ul class=pagination><span class="page-item page-prev"><a href=/page/5/ class=page-link aria-label=Previous><span aria-hidden=true>← Prev</span></a></span>
<span class="page-item page-next"><a href=/page/7/ class=page-link aria-label=Next><span aria-hidden=true>Next →</span></a></span></ul></main><footer><div style=display:flex><a class=soc href=https://github.com/anthonyhan rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=https://twitter.com/_qhan_ rel=me title=Twitter><i data-feather=twitter></i></a>
<a class=border></a><a class=soc href=/index.xml rel=me title=Rss><i data-feather=rss></i></a>
<a class=border></a></div><div class=footer-info>2023 © Anthony | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>